\section{GraphRule}

Die GraphRule ist die Neuerung und Innovation, die von \cite{shanbhag2014optimizing} vorgestellt wurde, mit deren Hilfe die Performance des Join-Orderings erheblich verbessert werden soll. Die neue Regel, wie bereits beschrieben, ersetzt die bestehenden Transformationsregeln von Pellenkoft. Sie stellt also keine Erweiterung im engeren Sinne, sondern einen Ersatz der Regel dar.

\subsection{Transformationsregel}


Die Graph Rule hat das selbe Interface \texttt{GraphRule($\Join, E_1, E_2, parent$)} wie alle anderen Regeln. Ziel der Regel ist es alle möglichen Transformationen für einen initalen Anfragegraphen mit nur einem Aufruf auszugeben. Daher wird der Operator, die linke und rechte Äquivalenzknoten sowie der Vater-Äquivalenzknoten übergeben. Aus der Menge der Join-Sets von linker und rechter Seite wird je ein JoinSet-Element genommen und mit Hilfe einer \texttt{merge}-Operation zusammengefügt. Falls dieses neue Element noch nicht Teil der Menge der JoinSet-Elemente des Vater-Äquivalenzknotens ist, wird weiter fortgefahren und das neue Element dem Vater bekanntgegeben. Aus dem neuen JoinSet-Element wird mit der Methode \texttt{CreateGraph} ein JoinGraph erzeugt. Dieser JoinGraph wird mit einer Partitionierungsmethode getrennt und so einzelne zusammenhängende Stücke des Graphen gebildet, die durch die Methode \texttt{CreateTree} zu einem neuen Baum zusammengefügt werden und damit ein Ergebnis bilden. Sobald über alle Join-Sets der linken und rechten Seite ($E_1, E_2$) iteriert wurde, kann das Gesamtergebnis zurückgeliefert werden. Eine weitere Ausführung der Regel ist ab diesem Moment nicht mehr notwendig, da bereits alle Pläne gefunden wurden.


Im Gegensatz zu den bisher vorgestellten Regeln, sind hier mehrere Routinen Teil der Regel und eine komplexere Bearbeitung notwendig. Die einzelnen bestandteile \texttt{merge}, \texttt{CreateTree}, \texttt{Partition}, \texttt{CreateGraph} werden nun im Detail angesprochen:


\subsubsection{merge}

Die \texttt{Merge}-Methode hat zwei Input Parameter. Jeder Parameter ist ein JoinSet-Element und kann beispielsweise ein Bitvektor sein. Diese beiden Vektoren werden zusammengefügt, so dass sie eine Repräsentation für beide JoinSet-Elemente bilden. Dieser neue Wert wird zurückgegeben.


