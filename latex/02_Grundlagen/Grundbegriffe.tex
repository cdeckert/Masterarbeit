

\subsection{Query Optimizer und Query Execution Engine}
Die Arbeit an Anfragenoptimierern wurde in den frühen 1970er Jahren begonnen und bis heute fortgesetzt. Dieses Kapitel beleuchtet die Geschichte der Anfragenoptimierung und basiert auf \cite{chaudhuri1998overview}.


Zu Beginn der Anfragenoptimierung steht die Anfrage. Eine Anfrage wird in einer Anfragesprache formuliert. Die Anfragesprache ist ein deklaratives, high-level Interface zum Zugriff auf Daten. In der Welt der relationalen Datenbanken hat sich SQL als Standardsprache durchgesetzt. Bei der Verarbeitung einer Anfrage durch ein DBMS sind zwei Komponenten entscheidend: (1) Der Query Optimizer  (QO) und (2) die Query Execution Engine (QEE).

Die QEE implementiert eine Reihe von physikalischen Operatoren. Die Aufgabe eines Operators ist es aus einem oder mehreren Eingabedatenströmen einen Ausgabedatenstrom zu erzeugen. Zu diesen physikalischen Operatoren gehören beispielsweise sort, index scan, sequencial scan, nested-loop join, und sort-merge. Es ist möglich, dass eine logische Operation als mehrere physiche Operationen ausgedrückt werden kann. Physische Operationen sind somit nicht 1:1 logischen Operationen zugeordnet. Physikalische Operatoren sind Codeblöcke die die Ausführung von Anfragen erlauben. Eine solche Anfrage lässt sich als Operatorenbaum darstellen und wird als Execution Plan bezeichnet. Die Ausführungsengine ist verantwortlich für die Ausführung eines Execution Plans und liefert als Resultat die Antwort auf eine Anfrage.

Die Aufgabe des QO ist es basierend auf einer zuvor geparsten Anfrage einen optimierten Plan zurückzuliefern, der als Input für den QEE dient. Als optimaler Plan gilt der, der am effektivsten durch den QEE ausgeführt werden kann. Die Aufgabe der Generierung des optimalen Plans ist nicht einfach, da eine Anfrage von vielen unterschiedlichen Plänen repräsentiert werden kann. Beispielsweise ist es möglich einen algebraischen Ausdruck in einen anderen logisch gleichen, jedoch in Form unterschiedlichen Ausdruck zu verwandeln. Ein Beispiel hierfür ist Kommutativität, auf die später genauer eingegangen wird:

$$ JOIN(A,B) = JOIN(B,A)$$

Ebenso ist es möglich, dass für die logische Repräsentation mehrere Execution Pläne zur Verfügung stehen. Beispielweise kann ein logischer JOIN von mehreren physikalischen JOIN Methoden repräsentiert werden.

Die Dauer der Ausführung eines Execution Plans kann von Plan zu Plan stark variieren. Daher ist es notwendig eine Auswahl zu treffen, welches der schnellste Plan für die Ausführung einer Anfrage ist. Um dieses Problem zu lösen, müssen drei Bereiche betrachtet werden:

\begin{itemize}
\item Der Suchraum (Search Space). Er bildet die Menge aller logisch äquivalenten Pläne.
\item Die Kostenschätzung (Cost Estimation). Ihre Aufgabe ist es die Kosten und schlussendlich die Dauer für die Ausführung eines Plans zu bestimmen.
\item Ein Enumeration Algorithm, der für die Suche innerhalb es Search Spaces verantwortlich ist.
\end{itemize}

Das Ziel eines jeden Optimierers ist es (1) einen Suchraum zu erzeugen, der den Plan enthält, der die niedrigsten Kosten verursacht, (2) eine akkurate Kostenschätzung abzugeben und (3) effizient nach dem günstigsten Plan zu suchen. Jeder dieser Ziele ist nicht trivial zu erreichen.



\subsection{Search Space}

Der Search Space bildet die Grundlage, innerhalb derer der Optimizer nach einem optimalen Plan suchen kann. Der Suchraum ist abhängig davon welche algebraischen Transformationen zur Anwendung kommen und welche physischen Operatoren durch den Optimierer unterstützt werden. Die Transformation von Plänen sorgt dabei nicht per se für einen optimierten und optimaleren Baum, sondern bildet nur Alternativen. Aus diesen wird mittels Kostenfunktionen und Enummeratoren der optimale Plan ausgewählt.

Einige Optimierer nutzen während der Verarbeitung einer Anfrage unterschiedliche Repräsentationsformen. Als initiale Repräsentationsform steht meist eine geparste Anfrage zur Verfügung. Das Resultat ist i.d.R. ein Operatorenbaum. Während der Verarbeitung durch den Optimierer kann zwischendurch auch ein logischer Operatorenbaum (auch Query Tree) genutzt werden.

Einige Systeme nutzen auch kalkülorientierte Repräsentationsformen zur Analyse der Struktur einer Anfrage. Solche Anfragen lassen sich in der Form von Query Graphen darstellen, deren Knoten Relationen repräsentieren und deren Kanten mit Join Prädikaten gekennzeichnet sind. So einfach diese Repräsentationsform ist, so schwierig ist diese in der Umsetzung. Diese Prädikate Graphen repräsentieren nur einen Teil der möglichen Operationen. Ein solcher Graph kann zwar natürliche Joins darstellen, die Repräsentation von UNION ist nicht möglich. Ebenfalls lassen sich verschachtelte Anfragen nicht darstellen. Diesem Nachteil tritt der GQM des Starburst Projektes entgegen. Ein GQM ist eine erweiterte Form der Query Graphen. Der GQM erlaubt es mit Hilfe von Building blocks einfache SQL Statements zu repräsetieren und weitere nested Query als Subgraphen darzustellen. Im Gegensatz dazu nutzt EXODUS und seine Nachfolger von vornherein einen uniformen Querybaum und Operatorenbaun für alle Phasen der Optimierung.



\subsection{Trees}

[HIER MEHR TEXT]
\cite{ioannidis1991left}
\begin{itemize}
\item Left-Deep / Right Deep
\item Zick-zack Tree
\item Bushytree
\end{itemize}