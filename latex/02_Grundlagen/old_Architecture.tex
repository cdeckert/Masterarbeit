

\subsection{\ac{QO} und \ac{QEE}}
Die Arbeit an Anfragenoptimierern wurde in den frühen 1970er Jahren begonnen und bis heute fortgesetzt. Dieses Kapitel beleuchtet die Geschichte der Anfragenoptimierung und basiert auf \cite{chaudhuri1998overview}.


\newpage
\subsection{Architektur eines \ac{DBMS}}

Der Aufbau eines \ac{DBMS} lässt sich in grob in zwei Teilsysteme Gliedern: \ac{CTS} und \ac{RTS} (vgl. \ref{DBMS_Architecture}).  Befehle werden in das \ac{CTS} durch den Nutzer eingeben und in durch das \ac{RTS} ausgeführt. Neben der Anfrage von Datensätzen (Query) sind auch andere Befehle wie Schemaveränderungen, die Erstellung von Indexen und das Update von Datensätzen möglich. Im Weiteren wird vor allem der Aspekt der Anfragen genauer beleuchtet.

Bei einer Query kommt entweder ein \ac{QC} oder \ac{QI} als Teil des \ac{CTS} zum Einsatz. Als Input dient eine Anfrage, die in einer Anfragesprache wie \ac{SQL} formuliert ist. Das Ergebnis des \ac{CTS} wird dem \ac{RTS} übergeben. Es übernimmt die Ausführung mit Hilfe einer \ac{QEE} und liefert das Ergebnis zurück an den Benutzer.

Innerhalb des \ac{CTS} gibt es zwei Möglichkeiten zur Umwandlung einer Anfrage: die Interpretierung – sie wird durch den \ac{QI} vorgenommen – und Kompilierung – sie wird durch den \ac{QC} ausgeführt. 

In \ref{fig:DBMS _Interpreter} ist ein Beispiel für einen \ac{QI} dargestellt. Er liesst die Anfrage, die meist als String vorliegt ein und übersetzt sie in eine interne Repräsentation. Die Repräsentation kann optinal Mittels eines Rewriters entschachtelt werden.

Im Gegensatz zur Interpretation läuft die Kompilierung in mehreren Schritten ab. Ein Beispiel \ac{QC} ist in \ref{fig:DMBS_Compiler_Example} dargestellt. Bei diesem Compiler wird ähnlich wie bei \ref{fig:DBMS_Interpreter} die Anfrage in eine interne Repräsentation umgesetzt. In einem nächsten Schritt wird jedoch ein kosten-optimaler äquivalenter Plan gefunden und in einem weiteren Schritt erneut mit Hilfe von Rewritern umgeschrieben. Das Ergebnis kann dann durch eine \ac{QEE} ausgeführt werden.

Die Architektur eines solchen \ac{QC} ist in \ref{fig:DBMS_Compiler_Architecture} dargestellt. Eine Anfrage, wird zuerst von einem Parser in einen abstrakten Syntaxbaum umgewandelt. Dieser Baum wird durch die Komponente NFST zuerst normalisiert. Die Anfrage wird faktorisiert und semantisch analysiert. Es entsteht eine interne Repräsentation des initialen Anfragekommandos. Diese Repräsentation an den \ac{QO} übergeben. Seine Aufgabe ist es den optimalen Plan zur Ausführung einer Anfrage zu generieren. Ein erster Schritt in diesem Prozess kann der Einsatz eines Rewriters sein. Beispielsweise kann hier Entschachtelung durchgeführt werden. Das Ergebnis wird dem \ac{PG} übergeben. Er erzeugt den optimalen Plan. Der Plan kann wieder mit Hilfe von Rewritern verändert werden. Das Ergebnis des \ac{QO} ist eine optimale Repräsentation der Initialen Anfrage. Sie wird durch den \ac{QC} in Code umgesetzt, der von einer \ac{QEE} verstanden und ausgeführt werden kann.


Die \ac{QEE} implementiert eine Reihe von physischen Operatoren. Die Aufgabe eines Operators ist es aus einem oder mehreren Eingabesträmen einen Ausgabedatenstrom zu erzeugen. Zu den physischen Operatoren gehören unter aderen: sort, index scan, sequencial scan, nested-loop-join und sort-merge. Es ist möglich, dass ein logischer Operator durch mehrere physische Operatoren oder eine Kombination von physischen Operatoren abgebildet werden kann. Eine Zuordnung von physischen und logischen Operatoren ist daher nicht 1:1 möglich. Diese Zuordnung wird während i.d.R. durch den \ac{QC} vorgenommen.


\subsection{\ac{QO}}

Bei der Optimierung einer Anfrage ist 


\newpage
\subsection{ALT}




Die Aufgabe des QO ist es basierend auf einer zuvor geparsten Anfrage einen optimierten Plan zurückzuliefern, der als Input für den QEE dient. Als optimaler Plan gilt der, der am effektivsten durch den QEE ausgeführt werden kann. Die Aufgabe der Generierung des optimalen Plans ist nicht einfach, da eine Anfrage von vielen unterschiedlichen Plänen repräsentiert werden kann. Beispielsweise ist es möglich einen algebraischen Ausdruck in einen anderen logisch gleichen, jedoch in Form unterschiedlichen Ausdruck zu verwandeln. Ein Beispiel hierfür ist Kommutativität, auf die später genauer eingegangen wird:

$$ JOIN(A,B) = JOIN(B,A)$$

Ebenso ist es möglich, dass für die logische Repräsentation mehrere Execution Pläne zur Verfügung stehen. Beispielweise kann ein logischer JOIN von mehreren physikalischen JOIN Methoden repräsentiert werden.

Die Dauer der Ausführung eines Execution Plans kann von Plan zu Plan stark variieren. Daher ist es notwendig eine Auswahl zu treffen, welches der schnellste Plan für die Ausführung einer Anfrage ist. Um dieses Problem zu lösen, müssen drei Bereiche betrachtet werden:

\begin{itemize}
\item Der Suchraum (Search Space). Er bildet die Menge aller logisch äquivalenten Pläne.
\item Die Kostenschätzung (Cost Estimation). Ihre Aufgabe ist es die Kosten und schlussendlich die Dauer für die Ausführung eines Plans zu bestimmen.
\item Ein Enumeration Algorithm, der für die Suche innerhalb es Search Spaces verantwortlich ist.
\end{itemize}

Das Ziel eines jeden Optimierers ist es (1) einen Suchraum zu erzeugen, der den Plan enthält, der die niedrigsten Kosten verursacht, (2) eine akkurate Kostenschätzung abzugeben und (3) effizient nach dem günstigsten Plan zu suchen. Jeder dieser Ziele ist nicht trivial zu erreichen.



\subsection{Search Space}



\subsection{Trees}

[HIER MEHR TEXT]
\cite{ioannidis1991left}
\begin{itemize}
\item Left-Deep / Right Deep
\item Zick-zack Tree
\item Bushytree
\end{itemize}



\subsubsection{Äuqivalenzklassen}

Um die Menge von gespeicherten Plänen zu reduzieren, redundante Transformation zu vermeiden und die Menge an Duplikaten zu verringern werden in Vulcano Äquivalenzklassen genutzt. Eine Äquivalenzklasse (auch kurz: Klasse) bezeichnet eine Menge von (Sub-)Plänen, die untereinander äquivalent sind. Für jeden Operator wird bei dieser Methode eine eigene Äquivalenzklasse erzeugt.

Zu Beginn werden aus dem Ursprungsplan mehrere Äquivalenzklassen gebildet. Jeder Operator des Ursprungsplans wird einer eigenen Äquivalenzklasse zugeordnet, die wiederum das Argument eines anderen Operators bildet. Auf jeden Plan der Klasse werden jeweils die Regeln des Regelsets angewendet und so neue Pläne und Äuqivalenzklassen erzeugt. Sobald auf alle Pläne und neuerzeugten Äquivalenzklassen alle Regeln angewendet wurden und dadurch auch keine neuen Pläne entstehen können, ist der Suchraum erforscht.

Basierend auf der Menge der Äquivalenzklassen kann durch einen rekursiven Aufruf alle Pläne des Suchraums erzeugt und ausgegeben werden.

