\subsection{System R Projekt}

IBMs System R \cite{selinger1979access}, \cite{wade2012ibm} gilt als der Pioneer auf dem Gebiet der dynamischen Programmierung von Algorithmen zur Bestimmung der optimalen Ausführungsreihenfolge von Joins. Das Projekt wurde bereits in den 1970er Jahren begonnen und diente als Vorgänger für DB2, dessen Prototyp im Folgenden ebenfalls besprochen wird.

Wie bei anderen relationalen Datenbanksystemen steht am Beginn eiener Anfrage an das System ein in \ac{SQL} formulierte Anfrage. Diese Anfrage wird in vier Schritten verarbeitet: Parsen,  Optimieren, Code Generierung und Ausführen.

Im ersten Schritt wird wie bei späteren Systemen die Syntax geprüft und die Anfrage in eine interne Repräsentation umgewandelt. Bei System R werden hierzu Query Blöcke verwendet. Sie repräsentieren die Anfrage mit einer SELECT list, einer FROM list und einem WHERE Baum, der eine Liste der Elemente beinhaltet, die beispielsweise zum JOIN von Tabellen und der Einschränkung von Datensätzen dienen. Es ist möglich, dass mehrere Query Blöcke für eine einzige Anfrage vorhanden sind. Dies geschieht dann, wenn eine Anfrage Inner-Queries verwendet bzw. Anfragen als Argumente für eine WHERE Bedingung zum Einsatz kommen.


Sobald die Anfrage in Query Blöcke verarbeitet wurde, kommt der Query Optimizer zum Einsatz. Der Optimierer prüft zuerst, ob die genutzten Relationen und Felder auch in der Datenbank vorhanden sind und schlägt Informationen über diese im System R Catalog nach. Teil dieser Informationen sind statistische Informationen der referenzierten Relationen. Diese werden später für die Auswahl der richtigen Access Plans verwendet.

Im nächsten Schritt bestimmt der Optimizer für jeden Query Block den optimalen Access-Pfad. Zuerst wird die Evaluationsreihenfolge der Query Blocks im Statement festgelegt. Dann wird für jeden Query Block die FROM Relationen betrachtet. Sind mehr als eine Relationen vorhanden, werden Permutationen der JOIN Order gebildet. Es wird der Pfad mit den günstigsten kosten gewählt und die notwendigen Modifikationen werden an der Anfrage vorgenommen. Das Resulat des Prozesses ist ein Plan in der \ac{ASL}.

Nachdem der Plan gefunden ist und als \ac{ASL}-Tree vorhanden ist, kommt der Code Generator zum Einsatz. Er übersetzt den \ac{ASL}-Plan in ein Maschinencode. Dieser Code führt die Anfrage des Nutzers auf der Datenbank aus. 

Der Maschinencode wird dann auf dem \ac{RSS} über das \ac{RSI} ausgeführt.  Das Ergebnis wird zurückgeliefert.

\subsubsection{Kostenberechnung}

Die Kostenberechnung in System R unterscheidet zwiscehn der Brechnung der Kosten für eine einzige Relation und der Berechnung von mehreren Relationen. Bei der Brechnung der Kosten für eine einzelne Relation werden basierend auf den Informationen aus dem System R Catalog gebildet.

Soll beispielsweise entschieden werden, ob eine Relation per Index Scan oder per Full Table Scan abgerufen wird, werden die Kosten mit dieser Formel berechnet:

$$Cost = Page Fetches + W * (RSI calls)$$


$Page Fetches$ repräsentieren die I/O Operationen, die beispielsweise durch den Abruf der Index Pages und der eigentlichen Pages entsteht. $RSI calls$ ist die Anzahl der erwarteten Datensätze, die durch das \ac{RSS} zurückgegeben werden. Sie dient als Abschätzung wie hoch der CPU aufwand für die Rückgabe der Werte ist. Mit Hilfe des Parameters $W$ wird eingestellt in welchem Verhänis I/O zu CPU Kosten stehen.

Bei der Auswahl eines Plans unterscheidet das System zwischen einer „interessanten“ Reihenfolge und einer ungeordneten Reihenfolge. Als interessante Reihenfolge, werden Reihenfolgen betrachtet, die geordnet sind. Bei der Berechnung eines ORDER BY bzw. eines GROUP BY Statements evaluiert der Optimierer falls möglich immer die Kosten für den Plan, der für die Ausgabe in „interssanter Reihenfolge“ notwendig sind und die Kosten, die für das lesen in ungeordneter Reihenfolge notwendig sind und addiert auf diese Kosten, die Kosten für das Ordnen der Ergebnisse Falls eine ungeordnete Reihenfolge + das Ordnen der Egebnisse gemeinsam kürzer dauert als das direkte Ausgeben einer interessanten Reihenfolge wird sich für die günstigere Variante entschieden. 

Die berechnung geschieht auf Daten, die durch den katalog bereitgestelt werden, Sie einthalten Informationen über die Kardinalität und die Anzahl der Segmente, die für das auslesen einer Relation notwendig sind, ebenfalls wird ein Selektivitätsfaktor genutzt, der das Verhätnis der Gesamtheit zur Eingeschlsossenen Menege der Anfrage angibt. Spring die Menge der ausgeschlossenen Tupel. 
\subsubsection{Plan Transformation}

\subsubsection{System Design}
Das System das bei System R verwendet wurde war hardwired und wenig erweiterbar. Die Regeln, die der Transformation einer Anfrage zu Grunde liegen, waren teil des Programmablaufs jedoch nicht als einzelne Komponenten ausgegliedert. 