\subsection{Exodus, Volcano, Cascades}

Das Volcano Projekt mit seinem Vorgänger \ac{EXODUS} und dem Nachfolger Cascades bildetete die Grundlage für den Microsoft SQL Server und dessen Anfragenoptimierer. Bei der Implementierung des Volcano Optimizers ist insbesondere die Implementierung des Query Optimizers von Interesse und wird daher ausführlich behandelt.

\subsubsection{Exodus}


Bereits in den 1970er Jahren begann Graefe mit der Implementierung eines DBMS Frameworks unter dem Titel EXODUS \cite{carey1990exodus} . Das Projekt, das die Grundlage für Volcano legen sollte, hatte sich zum Ziel gesetzt einen erweiterbaren, applikationsspezifischen und hochperformanten Baukasten zusammenzustellen, mit dessen Hilfe neue Datenbanksysteme generiert werden konnten. 

Im Gegensatz zu konventionellen DBMS wie Postgres handelt es sich bei EXODUS nicht um ein funktionsfähiges und sofort einsatzfähiges DBMS, sondern um einen Baukasten, auf dessen Basis ein neues System durch einen DBI erstellt werden kann. Im Gegensatz zu anwendungsübergreifend designten DBMS wie Postgres bietet EXODUS den Vorteil, dass eine Datenbank speziell für die Bedürfnisse eines Anwendungsfalles angepasst wird. Um dennoch das Ziel der Performance nicht aus den Augen zu verlieren, werden viele Komponenten nicht immer wieder auf einer grünen Wiese entwickelt, sondern auf dem Fundament des EXODUS Baukastens aufgebaut.

\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{02_Grundlagen/ExodusDatabaseSystemStructure.png}
  \caption{Exodus Database System Structure}
\end{figure}

Der Baukasten von EXODUS besteht aus drei Arten von Bausteinen: Bausteine die fix vorgegeben und nicht verändert werden sollen, Bausteinen, die speziell entwickelt werden müssen und Teilen, die generiert werden. Der Werkzeugkasten umfasst dabei nicht nur die Bausteine, sondern auch die Werkzeuge zur Bearbeitung und Generierung. Zu den Werkzeugen gehören ein Tool zur Erstellung eines Front-Ends für die Anfragesprache, ein Query Optimizer Generator und die Programmiersprache E (zusammen mit einem passenden Compiler). Mit Hilfe des Tools zur Erstellung eines Front-Ends für Anfragesprachen kann die Parser Komponente generiert werden. Der Query Optimizer wird als Resultat des Query Optimizer Generators erzeugt. (vgl. Fig. Exodus Database System Structure)

Neben den generierten Komponenten gibt es den E Compiler, der E Code in Objekt-Code übersetzt. Er kommt zum Einsatz, um die durch den Query Optimizer optimierte Anfrage in eine kompilierte Anfrage umzusetzen. Diese Komponente ist ähnlich wie der Storage Manager, der für die Verwaltung von Daten in der Datenbank genutzt wird, unveränderlich. 

Zwischen der kompilierten Anfrage und dem Storage Manager kommen zwei Komponenten zum Einsatz, die von einem DBI geschrieben werden müssen: Die Operator Methoden und Access Methoden. Diese beiden Komponenten dienen dazu die Anfrage in Code zu übersetzen, der durch den  Storage Manager ausgeführt wird.

Bei der Implementierung eines Optimierers kommen grundsätzlich zwei mögliche Ansätze in Frage: (1) interpretierte und (2) kompilierte Programmiersprachen. Bei EXODUS wurde zuerst die Implementierung mittels sog. "AI" Sprachen versucht. In einem Prototypen wurde mit Hilfe von Prolog ein Optimierer entwickelt. Für Prolog wurde sich entschieden, da diese Sprache Pattern Matching und eine Search Engine bereitstellt. (Auch unification konnte zum Einsatz gebracht werden, um elegant Query Trees zu erstellen.) Der Hauptvorteil eines interpretierten Ansatzes war aus Sicht von EXODUS die Möglichkeit neue Regeln zur Laufzeit des Programms hinzuzufügen. Trotz dieser Vorteile wurde der Ansatz als zu langsam verworfen. Auch der Vorteil Regeln während der Laufzeit hinzuzufügen, wird in der Literatur (QUELLE) als wenig nützlich bewertet. Statt dieses Ansatzes wurde in der Folge auf die Erstellung eines Generators, der in C geschrieben wurde, gesetzt. Der Generator erstellt basierend auf Regeln einen Optimierer in C, der wiederum kompiliert werden kann. Zwar war die Entwicklung des C Generators aufwändiger als die Implementierung in Prolog, jedoch konnte auf applikationsspezifische Notwendigkeiten, wie die Implementierung von speziellen Suchverfahren, Punkt genau eingegangen werden.


Der generierte Optimierer funktioniert so, dass er den Anfragebaum Schritt für Schritt transformiert. Die Information über bereits erstellte Baum-Alternativen wird in einer Datenstruktur namens MESH gespeichert. MESH wird außerdem genutzt um Pläne für Anfragenbäume zu speichern, die nicht beschnitten werden von der Datenstruktur. Zu jedem Zeitpunkt während der Optimierung kann eine große Menge an weiteren möglichen Transformationen. Diese wird in der Datenstruktur \"OPEN\" gespeichert. Sie ist eine Priority Queue. OPEN ist initialisiert mit Transformationen, die auf den initialen Tree angewendet werden können. Grundsätzlich funktioniert der Algorithmus wie folgt:

\begin{lstlisting}[caption={Exekution in EXODUS}]
While (OPEN is not empty)
	SELECT a transformation from OPEN
	Apply it to the correct node(s) in MESH
	DO method selection and cost analysis for the new node
	Add newly enabled transformations to OPEN

\end{lstlisting}

\subsubsection{Volcano}

Volcano ist der verbesserte Nachfolger von EXODUS. Zuerst war Volcano nur ein erweiterbares, paralleles System zur Anfragenausführung. Später wurde ein neuer Anfragenoptimierer-Generator hinzugefügt. 

Der Volcano-Optimizer-Generator wurde designt und implementiert. 





\subsubsection{Volcano Optimizer Generator}

Der Volcano Optimizer unterscheidet sich verglichen zu seinem Vorgänger EXODUS durch höhere Erweiterbarkeit. Er bietet Unterstützung für nicht triviale Kostenmodelle und physische Eigenschaften wie die Sortierreihenfolge von Relationen. Außerdem ist er effizienter durch die Kombination von dynamischer Programmierung, zielgerichteter Suche und \"Branch-and-Bound-pruning\". Im Vergleich zu anderen regelbasierten Optimieren ist das System unabhängig von einem gegebenen Datenmodell.

\subsubsection{Volcano Optimizer Generator}

Bei der Generierung eines Plans auf Grund einer Anfrage kommt bei Volcano ein Optimierer zur Anwendung, der speziell für den Anwendungsfall generiert wurde. Der Optimierer ist das Resultat einer Model Spezifikation, die von einem \ac{DBI} erstellt und durch einen Optimierer Generator in Source Code umgewandelt wird. Dieser Code wird mit Hilfe eines Compilers in das Endprodukt, den Optimierer, umgewandelt.

 \subsubsection{Design Prinzipien}

Der Optimierer folgt dabei fünf Designentscheidungen \cite{graefe1993volcano}, die die Erweiterbarkeit und eine effiziente Suche des Optimierers erlauben.

\begin{itemize}

\item Die erste Grundlage des Volcano Optimizers ist die Anwendung von algebraischen Techniken wie algebraische Operatoren und Äquivalenzklassen. Volcano unterscheidet dabei zwischen logischer und physischer Algebra. Die Umwandlung von logischer Algebra (der Anfrage) in die physische Algebra (einem Query Evaluation Plans) geschieht durch die Transformation der logischen Algebra mit Hilfe von kostenbasierten Mappings von Logischen Algorithmen.


\item Das zweite Prinzip sieht vor, dass die Information über algebraische Gesetze, die zur Transformation von Algebraischen Ausdrücken genutzt werden als Regeln und Pattern modular erfasst sind. Durch dieses Prinzip sind die einzelnen Regeln klar und transparent von einander getrennt und können zu Regelsets zusammengestellt werden. Einige dieser Regelsets werden im folgenden Kapitel behandelt.


\item Das dritte Prinzip betrifft den Input des Optimierers im Gegensatz zu anderen Optimierern (namentlich Stardust) setzt der Volcano Optimizer auf algebraische Äquivalenzen als Input Parameter. Andere Systeme nutzen hier mehrere Stufen an Umwandlung, um zwischen Query und Optimizer Input zu vermitteln. 

\item Kompilierung über Interpretierung von Regeln ist das vierte Prinzip, das zur Anwendung kommt. Da es sich bei der Generierung von äquivalenten Plänen um ein CPU intensives Geschäft handelt, wurde entschieden, dass die Regeln zur Transformation der Pläne kompiliert und nicht interpretiert werden. Zwar verliert der Optimierer daduch die Möglichkeit ad hoc neue Regeln in den Optimierer aufzunehemen. Diese Möglichkeit wird jedoch in der Praxis nicht benötigt.

\item Das letzte Prinzip ist, dass der Volcano Optimierer auf dynamisches Programmieren bei der Generierung von Programmen setzt. 


\end{itemize}





